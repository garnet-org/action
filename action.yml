name: 'GarnetAI'
description: 'Runs the Jibril security scanner for runtime threat detection'
branding:
  icon: 'shield'
  color: 'blue'

inputs:
  api_token:
    description: 'API token for GarnetAI service'
    required: true
  api_url:
    description: 'API URL for GarnetAI service'
    required: false
    default: 'https://api.garnet.ai'
  policy_path:
    description: 'Path to save the network policy file'
    required: false
    default: './config/netpolicy.yaml'
  garnetctl_version:
    description: 'Version of garnetctl CLI to download (without v prefix)'
    required: false
    default: 'latest'
  jibril_version:
    description: 'Jibril release version for the daemon (without v prefix)'
    required: false
    default: '0.0'
  debug:
    description: 'Enable detailed debug output'
    required: false
    default: 'false'

runs:
  using: "composite"
  steps:
    - name: Download and setup tools
      shell: bash
      run: |
        # Enable debug output if requested
        if [ "${{ inputs.debug }}" == "true" ]; then
          echo "DEBUG MODE ENABLED - Will provide detailed output"
          set -x
        fi
        # Set up versions
        GARNETCTL_VERSION="${{ inputs.garnetctl_version }}"
        JIBRIL_VERSION="${{ inputs.jibril_version }}"
        
        # Ensure we have the proper version format
        if [[ "$GARNETCTL_VERSION" != "latest" && "$GARNETCTL_VERSION" != v* ]]; then
          GARNETCTL_VERSION="v$GARNETCTL_VERSION"
        fi
        
        if [[ "$JIBRIL_VERSION" != v* ]]; then
          JIBRIL_VERSION="v$JIBRIL_VERSION"
        fi
        
        # Download garnetctl from GitHub
        echo "Downloading garnetctl $GARNETCTL_VERSION..."
        
        # Map OS and arch to garnetctl release names
        OS=$(uname -s)
        ARCH=$(uname -m)
        
        # Convert to garnetctl naming format
        if [ "$OS" = "Linux" ]; then
          GARNET_OS="Linux"
        elif [ "$OS" = "Darwin" ]; then
          GARNET_OS="Darwin"
        else
          echo "Unsupported OS: $OS"
          exit 1
        fi
        
        if [ "$ARCH" = "x86_64" ]; then
          GARNET_ARCH="x86_64"
        elif [ "$ARCH" = "aarch64" ] || [ "$ARCH" = "arm64" ]; then
          GARNET_ARCH="arm64"
        else
          echo "Unsupported architecture: $ARCH"
          exit 1
        fi
        
        # Construct download URL
        if [ "$GARNETCTL_VERSION" = "latest" ]; then
          GARNETCTL_URL="https://github.com/garnet-org/garnetctl-releases/releases/latest/download/garnetctl_${GARNET_OS}_${GARNET_ARCH}.tar.gz"
        else
          GARNETCTL_URL="https://github.com/garnet-org/garnetctl-releases/releases/download/$GARNETCTL_VERSION/garnetctl_${GARNET_OS}_${GARNET_ARCH}.tar.gz"
        fi
        
        echo "Downloading garnetctl from: $GARNETCTL_URL"
        
        # Create temporary directory for extraction
        GARNETCTL_TMP_DIR=$(mktemp -d)
        
        # Download and extract
        curl -sL "$GARNETCTL_URL" | tar -xz -C "$GARNETCTL_TMP_DIR"
        
        # Move binary to path
        mv "$GARNETCTL_TMP_DIR/garnetctl" /usr/local/bin/garnetctl
        chmod +x /usr/local/bin/garnetctl
        
        # Clean up
        rm -rf "$GARNETCTL_TMP_DIR"
        
        # Download Jibril loader
        echo "Downloading Jibril loader $JIBRIL_VERSION..."
        
        JIBRIL_URL="https://github.com/listendev/jibril-releases/releases/download/$JIBRIL_VERSION/loader"
        echo "Downloading Jibril loader from: $JIBRIL_URL"
        curl -sL -o /usr/local/bin/loader "$JIBRIL_URL"
        chmod +x /usr/local/bin/loader
        
        # Configure garnetctl
        garnetctl config set-baseurl ${{ inputs.api_url }}
        garnetctl config set-token ${{ inputs.api_token }}

    - name: Create GitHub context and agent
      shell: bash
      run: |
        # Step 1: Create the GitHub context file
        echo "Creating GitHub context file..."
        cat > github-context.json << EOF
        {
          "job": "${{ github.job }}",
          "run_id": "${{ github.run_id }}",
          "workflow": "${{ github.workflow }}",
          "repository": "${{ github.repository }}",
          "repository_owner": "${{ github.repository_owner }}",
          "event_name": "${{ github.event_name }}",
          "ref": "${{ github.ref }}",
          "sha": "${{ github.sha }}",
          "actor": "${{ github.actor }}",
          "runner_os": "${{ runner.os }}",
          "runner_arch": "${{ runner.arch }}"
        }
        EOF

        # Step 2: Create the agent
        echo "Creating GitHub agent..."
        AGENT_INFO=$(garnetctl create agent \
          --version "1.0.0" \
          --ip "127.0.0.1" \
          --machine-id "github-${{ github.run_id }}" \
          --kind github \
          --context-file github-context.json)

        # Extract agent details
        AGENT_ID=$(echo "$AGENT_INFO" | jq -r '.id')
        AGENT_TOKEN=$(echo "$AGENT_INFO" | jq -r '.agent_token')

        echo "Created agent with ID: $AGENT_ID"
        echo "AGENT_ID=$AGENT_ID" >> $GITHUB_ENV
        echo "AGENT_TOKEN=$AGENT_TOKEN" >> $GITHUB_ENV

    - name: Configure and start monitoring
      shell: bash
      run: |
        # Step 3: Get network policy
        echo "Getting network policy..."
        REPO_ID="${{ github.repository }}"
        WORKFLOW="${{ github.workflow }}"

        # Create directory for policy file if it doesn't exist
        POLICY_DIR=$(dirname "${{ inputs.policy_path }}")
        echo "Creating policy directory: $POLICY_DIR"
        mkdir -p "$POLICY_DIR"
        
        # Debug: Show working directory and directory structure
        if [ "${{ inputs.debug }}" == "true" ]; then
          echo "DEBUG: Current working directory: $(pwd)"
          echo "DEBUG: Directory structure:"
          ls -la "$POLICY_DIR"
          echo "DEBUG: Full path to policy file: $(realpath "${{ inputs.policy_path }}" 2>/dev/null || echo "Path not accessible: ${{ inputs.policy_path }}")"
        fi
        
        # Get the network policy and save it to the specified path
        echo "Fetching network policy for repository '$REPO_ID' and workflow '$WORKFLOW'..."
        garnetctl get network-policy merged \
          --repository-id "$REPO_ID" \
          --workflow-name "$WORKFLOW" \
          --format jibril \
          --output "${{ inputs.policy_path }}"

        # Check if policy file was created successfully
        if [ -f "${{ inputs.policy_path }}" ]; then
          echo "Network policy saved to ${{ inputs.policy_path }}"
          if [ "${{ inputs.debug }}" == "true" ]; then
            echo "DEBUG: Network policy content:"
            cat "${{ inputs.policy_path }}"
          fi
        else
          echo "ERROR: Network policy file was not created at ${{ inputs.policy_path }}"
          if [ "${{ inputs.debug }}" == "true" ]; then
            echo "DEBUG: Directory permissions:"
            ls -la $(dirname "${{ inputs.policy_path }}")
            echo "DEBUG: garnetctl version:"
            garnetctl --version
          fi
          exit 1
        fi

        # Step 4: Start Jibril with loader using config from ./config
        echo "Starting Jibril security monitoring..."
        export GARNET_AGENT_TOKEN="${{ env.AGENT_TOKEN }}"
        
        CONFIG_PATH="./config/jibril.yaml"
        echo "Running Jibril loader with config from $CONFIG_PATH"
        
        # Debug configuration before starting
        if [ "${{ inputs.debug }}" == "true" ]; then
          echo "DEBUG: Jibril configuration file content:"
          cat "$CONFIG_PATH"
          echo "DEBUG: Environment variables:"
          env | grep -E 'GARNET|PATH'
          echo "DEBUG: Loader executable:"
          which loader || echo "Loader not found in PATH"
          ls -la /usr/local/bin/loader || echo "Loader not found in /usr/local/bin"
        fi
        
        # Run the loader with detailed error handling
        if sudo -E loader --config "$CONFIG_PATH" --systemd enable-now; then
          echo "Security monitoring started successfully"
        else
          LOADER_EXIT=$?
          echo "ERROR: Failed to start Jibril loader. Exit code: $LOADER_EXIT"
          
          if [ "${{ inputs.debug }}" == "true" ]; then
            echo "DEBUG: Checking system logs for errors:"
            sudo journalctl -u jibril --no-pager -n 50 || echo "Unable to get journalctl logs"
            echo "DEBUG: Loader version information:"
            loader --version || echo "Unable to get loader version"
            echo "DEBUG: Run loader with --help to see options:"
            loader --help || echo "Unable to show loader help"
          fi
          
          exit $LOADER_EXIT
        fi